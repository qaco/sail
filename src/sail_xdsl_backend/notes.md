The Sail front-end is responsible for parsing the Sail specification files,
then applying the type checker to the specified ISA. Two objects are therefore
passed to the backends: the AST (essentially ```Ast.def list```, defined in
lib/parse\_ast.ml). and the typing environment (```Type_check.Env.t```,
defined in lib/type_chack.mli). These backends take the form of specialized
plugins (C, Coq, OCaml...). It's very easy to write the skeleton of such a
plugin, insert it into Sail and trigger it via the command line.

What we want is to program an XDSL (or IRDL, or TableGen...) back-end to
automatically generate the definition of an MLIR dialect from the
specification of an ISA. In particular, we're interested in the ARM 9.4-a ISA,
whose Sail specification has been generated by the ASL-to-Sail tool and is
available in the arm-v9.4-a folder in the github sail-arm directory.

Beyond the specification of registers (AST object ```DEF_register```),
the lowering of which to a MLIR definition language does not seem to pose
any major difficulties, the files ```instrs{32,64}*.sail``` contain
specifications of the assembly/binary instructions.

The resulting Sail specification does not reflect the syntactic structure of
the instructions (which is broken and lost by ASL-to-Sail) but their semantics.
It describes the execution (or decoding) of such instructions as functions.
The signature of such an execution function (AST object ```DEF_val```)
exhibits the types of the values which parameterize the underlying instruction.

This raises two immediates problems:
+ These function signatures don't describe  actual operands objects
  (registers, immediates...) but abstract datatypes (integers, bitfields...).
  These concrete objects, which are required to generate an MLIR dialect
  definition, seem to be fixed only in the definition of these functions
  (```DEF_fundef```). Question: does the Env.t provided to each plugin
  backend keep these instantiations in memory ?
+ At high level, the functions which describe instructions are not different
  from other functions (for instance describing lower-level operations such as
  registers getters/setters). However, we need to distinguish
  between them to generate MLIR operations only for ISA-related ones.
  At this point, the information is niether encapsulated is the type system,
  nor in any other specific language construct, but it seems to be
  systematically contained in fuction names. It is weak, but at least, it is
  not lost.
